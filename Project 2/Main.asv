% Load camera parameters
load('Parameters_V1_1.mat', 'Parameters1');
load('Parameters_V2_1.mat', 'Parameters2');
paramv1 = Parameters1;
paramv2 = Parameters2;
% Intrinsic parameters (Matrix K)
K_V1 = paramv1.Kmat;
K_V2 = paramv2.Kmat;

% Extrinsic parameters (Matrix P)
P_V1 = paramv1.Pmat;
P_V2 = paramv2.Pmat;

% Display
disp('Intrinsic Matrix K (View 1):');
disp(K_V1);
disp('Intrinsic Matrix K (View 2):');
disp(K_V2);

disp('Projection Matrix P (View 1):');
disp(P_V1);
disp('Projection Matrix P (View 2):');
disp(P_V2);


function projected_points = project3DTo2D(mocapPoints3D, P)
    % Append 1 to 3D points for homogeneous coordinates
    homogenous_points = [mocapPoints3D, ones(size(mocapPoints3D, 1), 1)]';
    
    % Project using P matrix
    projected = P * homogenous_points;
    
    % Convert to 2D by dividing by the third row (z component)
    projected_points = [projected(1, :) ./ projected(3, :); ...
                        projected(2, :) ./ projected(3, :)]';
end

% Load 3D points and parameters
load('mocapPoints3D.mat', 'pts3D');
mocap = pts3D';
projected_points_V1 = project3DTo2D(mocap, paramv1.Pmat);
projected_points_V2 = project3DTo2D(mocap, paramv2.Pmat);

% Plot on images
imshow('im1corrected.jpg'); hold on;
plot(projected_points_V1(:, 1), projected_points_V1(:, 2), 'ro');
title('Projected Points on View 1');

figure;
imshow('im2corrected.jpg'); hold on;
plot(projected_points_V2(:, 1), projected_points_V2(:, 2), 'bo');
title('Projected Points on View 2');


function recovered_points = triangulatePoints(P1, P2, points1, points2)
    num_points = size(points1, 1);
    recovered_points = zeros(num_points, 3);
    
    for i = 1:num_points
        A = [
            points1(i, 1) * P1(3, :) - P1(1, :);
            points1(i, 2) * P1(3, :) - P1(2, :);
            points2(i, 1) * P2(3, :) - P2(1, :);
            points2(i, 2) * P2(3, :) - P2(2, :)
        ];
        
        % Solve for 3D point (A*x = 0)
        [~, ~, V] = svd(A);
        homogeneous_point = V(:, end);
        recovered_points(i, :) = (homogeneous_point(1:3) / homogeneous_point(4))';
    end
end

% Use the projected points from Task 3.2
recovered_points = triangulatePoints(paramv1.Pmat, paramv2.Pmat, ...
                                     projected_points_V1, projected_points_V2);
% Compute error
error = mean(vecnorm(recovered_points - mocap, 2, 2));
disp(['Mean squared error: ', num2str(error)]);